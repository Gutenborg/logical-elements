<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite + TS</title>

  <link href="./bulma.min.css" rel="stylesheet" />

  <style>
    :not(:defined) {
      display: none;
    }
  </style>
</head>

<body class="container p-4">
  <header class="block">
    <h1 class="title is-1 has-text-centered pb-4">Logical Elements</h1>

    <p class="subtitle is-4 has-text-centered">A set of tools for creating logical HTML.</p>
  </header>

  <h2 class="title is-2">A Logical Approach</h2>

  <p class="block">Most JavaScript frameworks are trying to solve a problem with HTML which is its lack of logic-based
    functionality
    and focus on adding features that lets you merge features of JavaScript with HTML. They typically do this by
    bringing the HTML into the JavaScript domain and controlling the DOM sometimes through a virtual DOM and sometimes
    through a compiler that provides a JS-like experience which handles doing the tedious task of connecting JS and
    HTML. Each of these tools, React, Vue, Svelte, Ember, etc. requires that the code you write be transformed before a
    browser can read it.</p>

  <p class="block">Logical Elements is an attempt to provide framework-level reactivity and functionality without a
    build step. It
    allows you to write HTML that can talk directly to nearby JavaScript, reference deeply nested values, update when
    values change, and iterate over arrays and objects. In short, it provides elements that have logical functionality.
  </p>

  <h2 class="title is-2">Core Methods</h2>

  <p class="block">The main way that this is achieved is through the use of a few combined browser tools such as:</p>

  <ul class="block is-size-5 has-text-weight-bold">
    <li>- Custom Elements</li>
    <li>- Mutation Observers</li>
    <li>- Object Proxies</li>
    <li>- Treewalkers</li>
    <li>- Custom Events</li>
    <li>- And more!</li>
  </ul>

  <p class="block">The elements provided serve as both an authoring tool and as useful ways of providing basic logic in
    your HtML such
    as
    if and else statements and each loops.</p>

  <h3 class="title is-3">The LogicalElement Class</h3>

  <p class="block">The first tool is an enhanced HTMLElement class to use when authoring your own custom elements. It
    features the
    following enhancements:</p>

  <ul class="block">
    <li><span class="has-text-weight-bold">- Parsed Callback</span> - Fires when the element has been fully parsed with
      all of its children. This solves an issue
      with the Custom Element `connectedCallback` which triggers on the opening tag of an element and doesn't know
      anything
      about its children.</li>
    <li><span class="has-text-weight-bold">- Updated Callback</span> - Fires when a parsed, attributeChanged,
      childrenModified, or providerUpdated callback is also
      fired. Will batch any of those events together if they occur at the same time.</li>
    <li><span class="has-text-weight-bold">- Children Modified Callback</span> - Fires when the tree structure of the
      children changes.</li>
    <li><span class="has-text-weight-bold">- Provider Updated Callback</span> - Fires when any parent state provider
      updates their state.</li>
    <li><span class="has-text-weight-bold">- Provider Subscriptions</span> - Automatically subscribes to parent state
      providers and makes them available to the
      element.</li>
    <li><span class="has-text-weight-bold">- Update Scheduler</span> - Helps batch updates together to minimize the
      number of times an element runs its update logic
    </li>
    <li><span class="has-text-weight-bold">- Reactive Attribute Namespaces</span> - The ability to define reactive
      attributes and how to handle them. A reactive
      attribute will have a handler called on it on every update.</li>
    <li><span class="has-text-weight-bold">- Each Child Walker</span> - A treewalker that steps through each child of an
      element and fires a callback function on
      them.</li>
    <li><span class="has-text-weight-bold">- Lookup State Values</span> - Lookup values from a parent state provider.
    </li>
  </ul>

  <h3 class="title is-3">The ContextElement Class</h3>

  <p class="block">It extends the LogicalElement class and adds a reactive state to it to become a state provider.</p>

  <ul class="block">
    <li><span class="has-text-weight-bold">- Reactive State</span> - Uses JavaScript object proxies to capture update
      events and notify subscribers. Will trigger
      the
      `stateUpdated`, `providerUpdated`, and `updated` callbacks.</li>
    <li><span class="has-text-weight-bold">- State Updated Callback</span> - Fires when the state of this ContextElement
      instance updates.</li>
  </ul>

  <h3 class="title is-3">Reactive Attribute Namespaces</h3>

  <p class="block">One of the main primary functionalities is the ability to declare attribute namespaces that will be
    evaluated if
    there
    is a provider update anywhere above them. Take for example the `attr` namespace. You can use this to assign any
    value
    to another attribute on the same element.</p>

  <p class="block">A namespace gets broken down in this way:</p>

  <p class="block is-size-5 has-text-weight-bold">NAMESPACE:COMMAND="{PROVIDER_NAME.PROPERTY_NAME}"</p>

  <p class="block">So, using that information `attr` namespace will
    look
    up the value on the context and assign it to the indicated attribute, in this case the `disabled` attribute.</p>

  <p class="block">There are three provided reactive namespaces that are assigned by default to the ContextElement
    class:</p>

  <ul class="block">
    <li>
      <span class="has-text-weight-bold">- `attr:ATTRIBUTE_NAME`</span> - Assign values to attributes on the same
      element, will overwrite any current attribute values
    </li>

    <li>
      <span class="has-text-weight-bold">- `cls:CLASS_NAME|ANOTHER_CLASS_NAME`</span> - Conditionally assign class names
    </li>

    <li>
      <span class="has-text-weight-bold">- `on:EVENT_NAME`</span> - Add event listeners to the element for the specified
      event
    </li>

    <li>
      <span class="has-text-weight-bold">- `set:PROPERTY_NAME`</span> - Assign values to specific properties such as
      `textContent`
    </li>
  </ul>

  <p class="block">Any author of a LogicalElement can add their own reactive namespaces to be processed during the
    `updatedCallback`
    lifecycle.</p>

  <h2 class="title is-2">Base Components</h2>

  <h3 class="title is-3">Le-Context</h3>

  <p class="block">Allows the user to create a reactive state that can be consumed by its children.</p>

  <le-context name="leContextExample">
    <script>
      // Function that matches the name of the context and will be used to create the default state
      function leContextExample(state) {
        // Click event handlers
        const incrementCount = (event) => {
          state.store.count++;
        };

        const decrementCount = (event) => {
          state.store.count--;
        };

        // Whatever is returned is the default value of the state
        return {
          count: 0,
          decrementCount,
          incrementCount,
          tooHigh: state.derive((store) => store.count > 10),
          tooLow: state.derive((store) => store.count < -10),
        }
      }
    </script>

    <div class="columns is-centered is-align-items-center">
      <div class="column is-narrow">
        <button attr:disabled="{leContextExample.tooLow}" class="button" on:click="{leContextExample.decrementCount}"
          title="Decrease Count">
          <span class="icon">-</span>
        </button>
      </div>

      <div class="column is-narrow is-size-4">
        Count is: <span set:text="{leContextExample.count}"></span>
      </div>

      <div class="column is-narrow">
        <button attr:disabled="{leContextExample.tooHigh}" class="button" on:click="{leContextExample.incrementCount}"
          title="Increase Count">
          <span class="icon">+</span>
        </button>
      </div>
    </div>
  </le-context>

  <h3 class="title is-3">Le-If</h3>

  <p class="block">Allows the user to conditionally render children.</p>

  <le-context name="leIfExample">
    <script>
      function leIfExample(state) {
        const setActiveTab = (event) => {
          state.store.activeTab = event.target.dataset.tab;
        };

        // TO-DO: Look to see if the event system is a better way to handle element communication with the ReactiveState.derive() method
        // The `setActiveTab` event handler is able to learn about the event target, could I fire off `le-state-read` events to trigger the derive callback?
        // If I did that, then I could provide a regular handler and the state could be set in the CustomEvent.details property
        return {
          activeTab: "1",
          setActiveTab,
          isActiveTab: state.derive((store, reader) => store.activeTab === reader?.dataset?.tabId),
        }
      }
    </script>

    <div class="tabs">
      <ul>
        <li cls:is-active="{leIfExample.isActiveTab}" data-tab-id="1">
          <a data-tab="1" on:click="{leIfExample.setActiveTab}">
            Tab 1
          </a>
        </li>

        <li cls:is-active="{leIfExample.isActiveTab}" data-tab-id="2">
          <a data-tab="2" on:click="{leIfExample.setActiveTab}">
            Tab 2
          </a>
        </li>

        <li cls:is-active="{leIfExample.isActiveTab}" data-tab-id="3">
          <a data-tab="3" on:click="{leIfExample.setActiveTab}">
            Tab 3
          </a>
        </li>

        <li cls:is-active="{leIfExample.isActiveTab}" data-tab-id="4">
          <a data-tab="4" on:click="{leIfExample.setActiveTab}">
            Tab 4
          </a>
        </li>
      </ul>
    </div>

    <le-if condition="{leIfExample.isActiveTab}" data-tab-id="1">
      <p class="block is-size-4">Tab 1 is Active!</p>
    </le-if>

    <le-if condition="{leIfExample.isActiveTab}" data-tab-id="2">
      <p class="block is-size-4">Tab 2 is Active!</p>
    </le-if>

    <le-if condition="{leIfExample.isActiveTab}" data-tab-id="3">
      <p class="block is-size-4">Tab 3 is Active!</p>
    </le-if>

    <le-if condition="{leIfExample.isActiveTab}" data-tab-id="4">
      <p class="block is-size-4">Tab 4 is Active!</p>
    </le-if>
  </le-context>

  <h3 class="title is-3 pt-4">Le-Else</h3>

  <p class="block">Looks at sibling elements using validator functions to check if it needs to be shown. If any sibling
    validator
    returns true, it is hidden. Authors can define their own validator functions.</p>

  <le-context name="leElseExample">
    <script>
      function leElseExample(state) {
        const toggleBoolean = (event) => {
          const booleanIndex = event.target.dataset.booleanId;

          state.store[`boolean${booleanIndex}`] = !state.store[`boolean${booleanIndex}`];
        };

        // TO-DO: Make the if element more flexible and not require preset comparisons to function
        return {
          boolean1: false,
          boolean2: true,
          boolean3: false,
          boolean4: true,
          toggleBoolean,
        }
      }
    </script>

    <div class="columns gap-4">
      <div class="column is-narrow">
        <div class="columns is-flex-direction-column">
          <button data-boolean-id="1" class="button" on:click="{leElseExample.toggleBoolean}">Toggle Boolean 1</button>
          <button data-boolean-id="2" class="button" on:click="{leElseExample.toggleBoolean}">Toggle Boolean 2</button>
          <button data-boolean-id="3" class="button" on:click="{leElseExample.toggleBoolean}">Toggle Boolean 3</button>
          <button data-boolean-id="4" class="button" on:click="{leElseExample.toggleBoolean}">Toggle Boolean 4</button>
        </div>
      </div>

      <div class="column is-narrow">
        <le-if condition="{leElseExample.boolean1}">
          <p>Boolean 1 is: <span set:text="{leElseExample.boolean1}"></span></p>
        </le-if>

        <le-if condition="{leElseExample.boolean2}">
          <p>Boolean 2 is: <span set:text="{leElseExample.boolean2}"></span></p>
        </le-if>

        <le-if condition="{leElseExample.boolean3}">
          <p>Boolean 3 is: <span set:text="{leElseExample.boolean3}"></span></p>
        </le-if>

        <le-if condition="{leElseExample.boolean4}">
          <p>Boolean 4 is: <span set:text="{leElseExample.boolean4}"></span></p>
        </le-if>

        <le-else>
          <span>All Booleans are false!</span>
        </le-else>
      </div>
    </div>
  </le-context>

  <h3 class="title is-3 pt-5">Le-Each</h3>

  <p class="block">Allows the user to iterate over an array or an object.</p>

  <le-context name="leEachExample">
    <script>
      function leEachExample(state) {
        const addTask = (event) => {
          event.preventDefault();
          const formData = new FormData(event.target);

          state.store.tasks.push(formData.get("new-task"));
        };

        const deleteTask = (event) => {
          const taskId = event.target.dataset.taskId;

          state.store.tasks.splice(taskId, 1);
        }

        // TO-DO: Make the if element more flexible and not require preset comparisons to function
        return {
          tasks: [],
          addTask,
          deleteTask
        }
      }
    </script>

    <form on:submit="{leEachExample.addTask}">
      <div class="field">
        <label class="label" for="le-each-list-new-task">Add an item to the list</label>

        <div class="field-body">
          <div class="field has-addons">
            <div class="control">
              <input class="input" id="le-each-list-new-task" name="new-task" placeholder="Feed the cats" required />
            </div>

            <div class="control">
              <button class="button is-primary" data-tab="1" on:click="{leIfExample.setActiveTab}">
                Add Task
              </button>
            </div>
          </div>
        </div>
      </div>
    </form>

    <le-each list="{leEachExample.tasks}" as="task">
      <template>
        <li class="p-4">
          <span set:text={task}></span>
          <button class="delete is-medium is-danger" data-taskId="{task.index}" on:click="{leEachExample.deleteTask}"
            title="Delete Task"></button>
        </li>
      </template>

      <ul data-apply-template></ul>
    </le-each>

    <le-else>
      <p>No items in your list!</p>
    </le-else>
  </le-context>

  <script type="module" src="/src/main.ts"></script>
</body>

</html>